\section{Motivating Examples}

In this section, we present two simple examples to demonstrate the core idea
of ACDLP for bounded program verification.  For each example, we apply three
analysis techniques: \textit{abstract interpretation} (AI), SAT-based
\textit{bounded model checking} (BMC) and ACDLP. \\ 
%
\textbf{First Example}
The simple Control-Flow Graph (CFG) in Fig.~\ref{fig:example1} squares
a machine integer and checks that the result is positive.  To avoid
overflow, we assume the input~v has an upper bound~N.  This example 
demonstrates that a) interval analysis in ACDLP is more precise than a 
forward AI in the interval domain, and b) ACDLP with intervals 
can achieve a precision similar to that of octagonal AI without 
employing more sophisticated mechanisms such as trace partitioning~\cite{toplas07}.
%
\begin{figure}[t]
\centering
\begin{tabular}{c|c|c}
\hline
Control-Flow Graph & Interval Analysis in ACDLP & Octagon Analysis in ACDLP\\
\hline
\scriptsize
\begin{minipage}{3.3cm}
%\centering
%\vspace*{0.3cm}
\scalebox{.52}{\import{figures/}{example.pspdftex}}
%\caption{\label{fig:cfg}}
\end{minipage}
&
\begin{minipage}{5.7cm}
%\centering
\vspace*{0.3cm}
\scalebox{.5}{\import{figures/}{acdl_run.pspdftex}}\vspace*{0.1cm}
%\caption{\label{fig:itv}}
\end{minipage}
&
\begin{minipage}{3.6cm}
%\centering
\vspace*{0.3cm}
\scalebox{.5}{\import{figures/}{acdl_oct.pspdftex}}
%\caption{\label{fig:oct}}
\end{minipage}
\\
\hline
\end{tabular}
\caption{\label{fig:example1}
CFG and corresponding Abstract Conflict Graphs for Interval and Octagon Analysis}
\end{figure}
%


\noindent \textbf{AI versus ACDLP}
Conventional forward interval AI is too imprecise to verify safety of this program
owing to the control-flow join at node~n4.  For example, the
state-of-the-art AI tool Astr{\'e}e requires external hints, provided
by manually annotating the code with partition directives at n1.  This 
informs Astr{\'e}e to analyse program paths separately.

%\textbf{General Working Mechanism of ACDLP}
However, ACDLP can be understood as an algorithm to automatically infer such
partitions.  For the example in Fig.~\ref{fig:example1}, interval analysis
with ACDLP is sufficient to prove safety.  The analysis records the
decisions and deductions in a \textit{trail} data-structure.  The trail can
be viewed to represent a graph structure called the {\em Abstract Conflict
Graph} (ACG) that stores dependencies between decisions and deductions
nodes, similar to the way an \emph{Implication Graph}~\cite{cdcl} works in a SAT solver. 
Nodes of the ACG in the second column of Fig.~\ref{fig:example1} are
labelled with the CFG location and the corresponding abstract value. 
Beginning with the assumption that v=[0,5] at node~n1, the intervals
generated by forward analysis in the initial deduction phase at
\emph{decision level}~0 (DL0) are $x=[-5,5]$ and $z=[-25,25]$.  Clearly
these do not prove safety, as shown in ACG1.  ACDLP therefore makes a
heuristic decision, at DL1, to refine the analysis.  With the decision
$c=[1,1]$, interval analysis then concludes $x=[0,5]$ at node n4, which
leads to $(\mathrm{Error}{:}\;\bot)$ in ACG2, indicating that the error
location is unreachable and that the program is safe when $c=[1,1]$.

Reaching $(\mathrm{Error}{:}\;\bot)$ is analogous to reaching a conflict in
a propositional SAT solver.  At this point, a clause-learning SAT solver
learns a reason for the conflict and backtracks to a level such that the
learnt clause is \textit{unit}.  By a similar process, ACDLP learns that
$c=[0,0]$.  That is, all error traces must satisfy $(c \neq 1)$.  The
analysis discards all interval constraints that lead to the conflict and
backtracks to DL0.  ACDLP then performs interval analysis with the learnt
clause $(c \neq 1)$.  This also leads to a conflict, as shown in ACG3.  The
analysis cannot backtrack further and so terminates, proving the program
safe.  Thus, {\em decision} and {\em clause learning} are used to infer the
partitions necessary for a precise analysis.  Alternatively, the octagon
analysis in ACDLP---illustrated in the third column of
Fig.~\ref{fig:example1}---can prove safety with propagations only. 
No~decisions are required.  Forward AI with octagons in Astr{\'e}e is also
able to prove safety.  
%
\begin{table}[!b]
%\scriptsize
\begin{center}
{
\begin{tabular}{l|r|r|r|r|r|r}
\hline
  Solver & Domains & decisions & propagations & conflicts & conflict literals & restarts \\ \hline
  \multicolumn{7}{c}{Solver statistics for Fig.~\ref{fig:example1} (For N = 46000)} \\ \hline
  MiniSAT & $\boolvars \rightarrow \{t,f,?\} $ & 233 & 36436 & 162 & 2604 & 2 \\ \hline
  ACDLP & $\mathit{nodes} \rightarrow \intervals[\numvars]$ & 1 & 17 & 1 & 1 & 0 \\ \hline
  ACDLP & $\mathit{nodes} \rightarrow \octagons[\numvars]$ & 0 & 7 & 0 & 0 & 0 \\ \hline 
  \multicolumn{7}{c}{Solver statistics for Fig.~\ref{fig:example2}} \\ \hline
  MiniSAT & $\boolvars \rightarrow \{t,f,?\} $ & 4844 & 32414 & 570 & 4750 & 5 \\ \hline
  ACDLP & $\mathit{nodes} \rightarrow \octagons[\numvars]$ & 4 & 412 & 2 & 2 & 0 \\ 
\hline
\end{tabular}
}
\end{center}
\caption{SAT-based BMC versus ACDLP for verification of programs in Fig.~\ref{fig:example1} and
  Fig.~\ref{fig:example2}}
\label{solver}
\end{table}
%
%
\begin{figure}[t]
\centering
\begin{tabular}{c|c}
\hline
Control-Flow Graph & Octagon Analysis in ACDLP \\
\hline
\scriptsize
\begin{minipage}{5.28cm}
%\centering
%\vspace*{0.3cm}
\scalebox{.52}{\import{figures/}{cfg.pspdftex}}
%\caption{\label{fig:cfg}}
\end{minipage}
&
\begin{minipage}{7.5cm}
%\centering
\vspace*{0.3cm}
\scalebox{.5}{\import{figures/}{oct_partition.pspdftex}}\vspace*{0.1cm}
%\caption{\label{fig:itv}}
\end{minipage}
\\
\hline
\end{tabular}\caption{\label{fig:example2}
CFG and corresponding Abstract Conflict Graphs for Octagon Analysis}
\end{figure}
%


\noindent \textbf{Second Example} Fig.~\ref{fig:example2}, demonstrates that 
octagon analysis in ACDLP is more precise than forward AI in the octagon domain.
% LATER, b) \emph{ACDLP with octagons can outperform SAT-based BMC}.  
The CFG in Fig.~\ref{fig:example2} computes the absolute 
values of two variables, $x$ and~$y$, under the assumption 
$(x=y) \lor (x=-y)$. 

\noindent \textbf{AI versus ACDLP}
Forward AI in the octagon domain infers 
the octagonal constraint $\mathrm{Error}{:}\;(p\geq0 \wedge p+q\geq0 \wedge q\geq0 \wedge p+x\geq0 \wedge 
p-x\geq0 \wedge q+y\geq0 \wedge q-y\geq0)$. Clearly this is too 
imprecise to prove safety. 
%
The octagonal analysis in ACDLP is illustrated by the ACGs in
Fig.~\ref{fig:example2}.  Due to space limitations, we elide intermediate
deductions with dotted lines.  The decision $x=y$ at DL1 is not sufficient
to prove safety, as shown in ACG1.  Hence, a new decision $x<0$ is made at
DL2, followed by forward propagation that infers $y<0$ at node n5.  This
subsequently leads to safety ($\mathrm{Error}{:}\;\bot$), as shown in ACG2. 
The analysis learns the reason for the conflict, discards all deductions in
ACG2 and backtracks to DL1.  Octagon analysis is run with the learnt
constraint $(x\geq0)$ and this infers $y\geq0$ at node n5, as shown in ACG3. 
This also leads to safety ($\mathrm{Error}{:}\;\bot$).  The analysis now
makes a new decision $x=-y$ at DL1.  The procedure is repeated leading to
results shown in ACG4, ACG5, and ACG6.  Clearly, the decisions $x=-y$ and
$x<0$ also lead to safety.  The analysis backtracks to DL0 and returns {\em
safe}.  Note that the specific decision heuristic we use in this case
exploits the control structure of the program to infer partitions that are
sufficient to prove safety. \\ \\
%
\noindent \textbf{ACDLP versus BMC}
ACDLP can require many fewer iterations than SAT-based BMC due to its
ability to reason over much richer lattice structures.
%in terms of number of {\em decisions}, {\em propagations}, and {\em conflicts}. 
A SAT-based BMC converts the program into a bit-vector equation 
and passes that to a CDCL-based SAT solver for proving safety.  
Table~\ref{solver} compares the statistics for BMC with 
MiniSAT~\cite{minisat} solver to those for interval and octagon 
analysis in ACDLP. In the column labelled $\textrm{Domains}$, 
$\boolvars$ is the set of propositional variables; each of these is mapped to
{\em true} (t), {\em false} (f) or {\em unknown} $(?)$. $\numvars$ is the set of
numerical variables, $\mathit{nodes}$ the set of nodes in the CFG;
$\intervals[\numvars]$ and $\octagons[\numvars]$ are the Interval and Octagon
domains over $\numvars$. As can be seen, ACDLP outperforms BMC in the total number of 
{\em decisions}, {\em propagations}, {\em learnt clauses} and {\em restarts} 
for both example programs.

\Omit{
However, in contrast to a SAT solver, the octagonal analysis in ACDLP is 
very efficient, as shown in Table~\ref{solver2}.  \rmcmt{This shows the advantage 
of using richer abstract domains within the CDCL-style analysis}.  
%
\begin{table}[!b]
\begin{center}
{
\begin{tabular}{l|r|r|r|r|r|r}
\hline
  Solver & Domain & decisions & propagations & conflicts & conflict literals & restarts \\ \hline
  MiniSAT & $\boolvars \rightarrow \{t,f,?\} $ & 4844 & 32414 & 570 & 4750 & 5 \\ \hline
  ACDLP & $\mathit{nodes} \rightarrow $ & 4 & 412 & 2 & 2 & 0 \\ 
\hline
\end{tabular}
}
\end{center}
\caption{Solver statistics for Example given in Fig.~\ref{fig:example2}}
\label{solver2}
\end{table}
}
