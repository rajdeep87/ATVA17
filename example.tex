\section{Motivating Examples}

We present two simple examples to demonstrate the essence
of ACDLP for bounded verification.  For each one, we apply three
analysis techniques: \textit{abstract interpretation} (AI), SAT-based
\textit{bounded model checking} (BMC) and ACDLP.

\bigskip

\noindent\textbf{First Example.} The simple Control-Flow Graph (CFG) in
Fig.~\ref{fig:example1} squares a machine integer and checks whether the result
is positive.  To avoid overflow, we assume the input~v has an upper bound~N. 
This example shows that a) interval analysis in ACDLP is more precise
than a forward AI in the interval domain, and b) ACDLP with intervals can
achieve a precision similar to that of AI with octagons without employing
more sophisticated mechanisms such as trace partitioning~\cite{toplas07}.

\begin{figure}[t]
\centering
\begin{tabular}{c|c|c}
CFG & ACDLP with Intervals &
\begin{minipage}{2cm}
\centering
ACDLP with Octagons
\end{minipage} \\
\hline
\scriptsize
\begin{minipage}{3.5cm}
%\centering
%\vspace*{0.3cm}
\scalebox{.6}{\import{figures/}{example.pspdftex}}
%\caption{\label{fig:cfg}}
\end{minipage}
&
\begin{minipage}{5.7cm}
%\centering
\vspace*{0.3cm}
\scalebox{.5}{\import{figures/}{acdl_run.pspdftex}}\vspace*{0.1cm}
%\caption{\label{fig:itv}}
\end{minipage}
&
\begin{minipage}{1.75cm}
%\centering
\vspace*{0.3cm}
\scalebox{.5}{\import{figures/}{acdl_oct.pspdftex}}
%\caption{\label{fig:oct}}
\end{minipage}
\\
\end{tabular}
\caption{\label{fig:example1}
CFG and corresponding Abstract Conflict Graphs
for intervals and octagons}
\end{figure}

\medskip

\noindent \textbf{AI versus ACDLP.}
Conventional forward interval AI is too imprecise to verify safety of this
program owing to the control-flow join at node~$n_4$.  For example, the
state-of-the-art AI tool Astr{\'e}e requires external hints, provided by
manually annotating the code with partition directives at $n_1$.  This
tells Astr{\'e}e to analyse the program paths separately.

%\textbf{General Working Mechanism of ACDLP}
ACDLP can be understood as an algorithm to infer such
partitions automatically.  For the example in Fig.~\ref{fig:example1}, interval analysis
with ACDLP is sufficient to prove safety.  The analysis records the
decisions and deductions in a \textit{trail} data-structure.  The trail can
be seen to represent a graph structure called the {\em Abstract Conflict
Graph} (ACG) that stores dependencies between decisions and deductions, similar to the way an \emph{Implication Graph}~\cite{cdcl} works in a SAT solver. 
Nodes of the ACG in the second column of Fig.~\ref{fig:example1} are
labelled with the CFG location and the corresponding abstract value. 
Beginning with the assumption that $v=[0,5]$ at node~$n_1$, the intervals
generated by forward analysis in the initial deduction phase at
\emph{decision level}~0 (DL0) are $x=[-5,5]$ and $z=[-25,25]$.  
These do not prove safety, as shown in ACG1.  So ACDLP makes a
heuristic decision, at DL1, to refine the analysis.  With the decision
$c=[1,1]$, interval analysis then concludes $x=[0,5]$ at node~$n_4$, which
leads to $(\mathrm{Error}{:}\;\bot)$ in ACG2, indicating that the error
location is unreachable and the program is safe when $c=[1,1]$.

Reaching $(\mathrm{Error}{:}\;\bot)$ is analogous to reaching a conflict in
a propositional SAT solver.  At this point, a clause-learning SAT solver
learns a reason for the conflict and backtracks to a level such that the
learnt clause is \textit{unit}.  By a similar process, ACDLP learns that
$c=[0,0]$.  That is, all error traces must satisfy $(c \neq 1)$.  The
analysis discards all interval constraints that lead to the conflict and
backtracks to DL0.  ACDLP then performs interval analysis with the learnt
clause $(c \neq 1)$.  This also leads to a conflict, as shown in ACG3.  The
analysis cannot backtrack further and so terminates, proving the program
safe.  Thus, {\em decision} and {\em clause learning} are used to infer the
partitions necessary for a precise analysis.  Alternatively, the octagon
analysis in ACDLP---illustrated in the third column of
Fig.~\ref{fig:example1}---can prove safety with propagations only. 
No~decisions are required.  Forward AI with octagons in Astr{\'e}e is also
able to prove safety.  
%
\begin{table}[!b]
%\scriptsize
\begin{center}
{
\begin{tabular}{l|l|r|r|r|r|r}
\hline
  Solver & Domain & decisions & propagations & conflicts & conflict literals & restarts \\ \hline
  \multicolumn{7}{c}{Solver statistics for Fig.~\ref{fig:example1} (For N = 46000)} \\ \hline
  MiniSAT & $\boolvars \rightarrow \{t,f,?\} $ & 233 & 36436 & 162 & 2604 & 2 \\ \hline
  ACDLP & $\mathit{nodes} \rightarrow \intervals[\numvars]$ & 1 & 17 & 1 & 1 & 0 \\ \hline
  ACDLP & $\mathit{nodes} \rightarrow \octagons[\numvars]$ & 0 & 7 & 0 & 0 & 0 \\ \hline 
  \multicolumn{7}{c}{Solver statistics for Fig.~\ref{fig:example2}} \\ \hline
  MiniSAT & $\boolvars \rightarrow \{t,f,?\} $ & 4844 & 32414 & 570 & 4750 & 5 \\ \hline
  ACDLP & $\mathit{nodes} \rightarrow \octagons[\numvars]$ & 4 & 412 & 2 & 2 & 0 \\ 
\hline
\end{tabular}
}
\end{center}
\caption{SAT-based BMC versus ACDLP for verification of programs in Figs.~\ref{fig:example1} and~\ref{fig:example2}}
\label{solver}
\end{table}
%
%
\begin{figure}[t]
\centering
\begin{tabular}{c|c}
CFG & ACDLP with Octagons \\
\hline
\scriptsize
\begin{minipage}{5.28cm}
%\centering
%\vspace*{0.3cm}
\scalebox{.52}{\import{figures/}{cfg.pspdftex}}
%\caption{\label{fig:cfg}}
\end{minipage}
&
\begin{minipage}{7.5cm}
%\centering
\vspace*{0.3cm}
\scalebox{.5}{\import{figures/}{oct_partition.pspdftex}}\vspace*{0.1cm}
%\caption{\label{fig:itv}}
\end{minipage}
\\
\end{tabular}\caption{\label{fig:example2}
CFG and corresponding Abstract Conflict Graphs for Octagon Analysis}
\end{figure}
%

\bigskip

\noindent \textbf{Second Example.} Fig.~\ref{fig:example2}, shows that 
octagon analysis in ACDLP is more precise than forward AI in the octagon domain.
% LATER, b) \emph{ACDLP with octagons can outperform SAT-based BMC}.  
The CFG in Fig.~\ref{fig:example2} computes the absolute 
values of two variables, $x$ and~$y$, under the assumption 
$(x=y) \lor (x=-y)$. 

\medskip

\noindent \textbf{AI versus ACDLP.}
Forward AI in the octagon domain infers 
the octagonal constraint $\mathrm{Error}{:}\;(p\geq0 \wedge p+q\geq0 \wedge q\geq0 \wedge p+x\geq0 \wedge 
p-x\geq0 \wedge q+y\geq0 \wedge q-y\geq0)$. Clearly this is too 
imprecise to prove safety. 
%
The octagonal analysis in ACDLP is illustrated by the ACGs in
Fig.~\ref{fig:example2}.  (Due to space limitations, we elide intermediate
deductions.) The decision $x=y$ at DL1 is not sufficient
to prove safety, as shown in ACG1.  So a new decision $x<0$ is made at
DL2, followed by forward propagation that infers $y<0$ at node~$n_5$.  This
subsequently leads to safety ($\mathrm{Error}{:}\;\bot$), as shown in ACG2. 
The analysis learns the reason for the conflict, discards all deductions in
ACG2 and backtracks to DL1.  Octagon analysis is run with the learnt
constraint $(x\geq0)$ and this infers $y\geq0$ at node~$n_5$, as shown in ACG3. 
This also leads to safety ($\mathrm{Error}{:}\;\bot$).  The analysis now
makes a new decision $x=-y$ at DL1.  The procedure is repeated leading to
results shown in ACG4, ACG5, and ACG6.  Clearly, the decisions $x=-y$ and
$x<0$ also lead to safety.  The analysis backtracks to DL0 and returns {\em
safe}.  Note that the specific decision heuristic we use in this case
exploits the control structure of the program to infer partitions that are
sufficient to prove safety. 

\medskip

\noindent \textbf{ACDLP versus BMC.}
ACDLP can require many fewer iterations than SAT-based BMC due to its
ability to reason over much richer lattice structures.
%in terms of number of {\em decisions}, {\em propagations}, and {\em conflicts}. 
A~SAT-based BMC converts the program into a bit-vector formula 
and passes it to a CDCL-based SAT solver for proving safety.  
Table~\ref{solver} compares the statistics for BMC with 
MiniSAT~\cite{minisat} solver to those for interval and octagon 
analysis in ACDLP. In the column labelled $\textrm{Domains}$, 
$\boolvars$ is the set of propositional variables; each of these is mapped to
{\em true} (t), {\em false} (f) or {\em unknown} $(?)$. $\numvars$ is the set of
numerical variables, $\mathit{nodes}$ the set of nodes in the CFG;
$\intervals[\numvars]$ and $\octagons[\numvars]$ are the Interval and Octagon
domains over $\numvars$. As can be seen, ACDLP outperforms BMC in the total number of 
{\em decisions}, {\em propagations}, {\em learnt clauses} and {\em restarts} 
for both example programs.

\Omit{
However, in contrast to a SAT solver, the octagonal analysis in ACDLP is 
very efficient, as shown in Table~\ref{solver2}.  \rmcmt{This shows the advantage 
of using richer abstract domains within the CDCL-style analysis}.  
%
\begin{table}[!b]
\begin{center}
{
\begin{tabular}{l|r|r|r|r|r|r}
\hline
  Solver & Domain & decisions & propagations & conflicts & conflict literals & restarts \\ \hline
  MiniSAT & $\boolvars \rightarrow \{t,f,?\} $ & 4844 & 32414 & 570 & 4750 & 5 \\ \hline
  ACDLP & $\mathit{nodes} \rightarrow $ & 4 & 412 & 2 & 2 & 0 \\ 
\hline
\end{tabular}
}
\end{center}
\caption{Solver statistics for Example given in Fig.~\ref{fig:example2}}
\label{solver2}
\end{table}
}
